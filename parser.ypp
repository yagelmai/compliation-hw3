%{ 
	#include <iostream>	
	#include <stdlib.h>
	#include <stdio.h>
	#include "parser.hpp"
	#include "main.hpp"
	#include "output.hpp"
    #include "hw3_output.hpp"
    using namespace output;
	int yylex();
	extern int yylineno;
	void yyerror(const char*);
%}

//
%right ASSIGN
%left OR
%left AND
%left RELATIONAL
%left ADDITIVE
%left MULTIPLICATIVE
%right NOT
%left LPAREN
%left RPAREN
%nonassoc VOID
%nonassoc INT
%nonassoc BYTE
%nonassoc B
%nonassoc BOOL
%nonassoc TRUE
%nonassoc FALSE
%nonassoc RETURN
%nonassoc IF
%nonassoc ELSE
%nonassoc WHILE
%nonassoc BREAK
%nonassoc CONTINUE
%nonassoc SC
%nonassoc COMMA
%nonassoc LBRACE
%nonassoc RBRACE
%nonassoc ID
%nonassoc NUM
%nonassoc STRING



%%


Prog:               Funcs               										{printProductionRule(1);}
;

Funcs:              FuncDecl Funcs    										{printProductionRule(3);}
                    | /* epsilon */       										{printProductionRule(2);}
;

FuncDecl:           RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE   {printProductionRule(4);}
;

RetType:            Type                										{printProductionRule(5);}
                    |  VOID             										{printProductionRule(6);}
;

Formals:            FormalsList       										{printProductionRule(8);}
                    | /* epsilon */       										{printProductionRule(7);}
;

FormalsList:        FormalDecl          										{printProductionRule(9);}
                    | FormalDecl COMMA FormalsList  							{printProductionRule(10);}
;

FormalDecl:         Type ID         				 							{printProductionRule(11);}
;

Statements:         Statement           										{printProductionRule(12);}
                    | Statements Statement  									{printProductionRule(13);}
;

Statement:          LBRACE Statements RBRACE    								{printProductionRule(14);}
                    | Type ID SC 											    {$$ = new Statement($1,$2);}
                    | Type ID ASSIGN Exp SC  									{printProductionRule(16);}
                    | ID ASSIGN Exp SC  										{printProductionRule(17);}
                    | Call SC           										{printProductionRule(18);}
                    | RETURN SC         										{printProductionRule(19);}
                    | RETURN Exp SC     										{printProductionRule(20);}
                    | IF LPAREN Exp RPAREN Statement                            {printProductionRule(21);}
                    | IF LPAREN Exp RPAREN Statement ELSE Statement             {printProductionRule(22);}
                    | WHILE LPAREN Exp RPAREN Statement                         {printProductionRule(23);}
                    | BREAK SC          										{printProductionRule(24);}
                    | CONTINUE SC       										{printProductionRule(25);}

Call:               ID LPAREN ExpList RPAREN    								{printProductionRule(26);}
                    | ID LPAREN RPAREN          								{printProductionRule(27);}
;

ExpList:            Exp                         								{printProductionRule(28);}
                    | Exp COMMA ExpList         								{printProductionRule(29);}
;

Type:               INT                         								{printProductionRule(30);}
                    | BYTE                      								{printProductionRule(31);}
                    | BOOL                      								{printProductionRule(32);}
;

Exp:                LPAREN Exp RPAREN           								{printProductionRule(33);} 
                    | Exp MULTIPLICATIVE Exp           						    {printProductionRule(34);} // (x = 3 if 4>5 else 2) //x=2
                    | Exp ADDITIVE Exp           								{printProductionRule(34);} // (x = 3 if 4>5 else 2) //x=2
                    | ID                        								{printProductionRule(35);}
                    | Call                      								{printProductionRule(36);}
                    | NUM                       								{printProductionRule(37);}
                    | NUM B                     								{printProductionRule(38);}
                    | STRING                    								{printProductionRule(39);}
                    | TRUE                      								{printProductionRule(40);}
                    | FALSE                     								{printProductionRule(41);}
                    | NOT Exp                   								{printProductionRule(42);}
                    | Exp AND Exp               								{printProductionRule(43);}
                    | Exp OR Exp                								{printProductionRule(44);}
                    | Exp RELATIONAL Exp             							{printProductionRule(45);}
                    | LPAREN Type RPAREN Exp    								{printProductionRule(46);}

;

%%

void yyerror(const char*)											{errorSyn(yylineno); exit(1);}

int main() 										{
	return yyparse();
}
