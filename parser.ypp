%{ 
	#include <iostream>	
	#include <stdlib.h>
	#include <stdio.h>
    #define YYSTYPE Node*
    #include "global_symbs.hpp"         // all actions and the DS
    #include "hw3_output.hpp"
    using namespace output;
    #include "parser.hpp"
	int yylex();
	extern int yylineno;
	void yyerror(const char*);
    using namespace std;
%}

//
%right ASSIGN
%left OR
%left AND
%left RELATIONAL
%left ADDITIVE
%left MULTIPLICATIVE
%right NOT
%left LPAREN
%left RPAREN
%nonassoc VOID
%nonassoc INT
%nonassoc BYTE
%nonassoc B
%nonassoc BOOL
%nonassoc TRUE
%nonassoc FALSE
%nonassoc RETURN
%nonassoc IF
%nonassoc ELSE
%nonassoc WHILE
%nonassoc BREAK
%nonassoc CONTINUE
%nonassoc SC
%nonassoc COMMA
%nonassoc LBRACE
%nonassoc RBRACE
%nonassoc ID
%nonassoc NUM
%nonassoc STRING



%%


Prog:               Funcs               										{}//check if main function exists, print scope
;

Funcs:              FuncDecl Funcs    										    {}
                    | /* epsilon */       										{}
;

FuncDecl:           RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE   {DS->addFunction();DS->clearFormals();}//check if function with ID exists?
;

RetType:            Type                										{DS->currentFunctionType($1->type);}
                    | VOID             										    {DS->currentFunctionType(TYPE_VOID);}
;

Formals:            FormalsList       										    {}//make sure to save all formals with negative offsets
                    | /* epsilon */       										{}
;

FormalsList:        FormalDecl          										{}//save variables at negative offsets.
                    | FormalDecl COMMA FormalsList  							{}
;

FormalDecl:         Type ID         				 							{DS->addFormal((Type*)$1->type,$2);delete (Type*)$1;}
;

Statements:         Statement           										{;}
                    | Statements Statement  									{;}
;

Statement:          LBRACE Statements RBRACE    								{;}
                    | Type ID SC 											    {DS->addSymbol($1->type,$2);delete (Type*)$2;}
                    | Type ID ASSIGN Exp SC  									{compareTypesAssignment((Type*)$1->type,(Expression*)$4->type);DS->addSymbol($1->type,$2);delete (Type*)$2;}
                    | ID ASSIGN Exp SC  										{compareTypesAssignment(DS->getVarType($1),(Expression*)$3->type);}
                    | Call SC           										{delete (Expression*)$1;}
                    | RETURN SC         										{DS->checkFunctionType(TYPE_VOID);}
                    | RETURN Exp SC     										{DS->checkFunctionType((Expression*)$2->type);}
                    | IF LPAREN Exp RPAREN Statement                            {checkIfBool((Expression*)$3->type);delete (Expression*)$3;}
                    | IF LPAREN Exp RPAREN Statement ELSE Statement             {checkIfBool((Expression*)$3->type);delete (Expression*)$3;}
                    | WHILE LPAREN Exp RPAREN WhileM Statement                  {checkIfBool((Expression*)$3->type);delete (Expression*)$3;DS->exitWhile();}
                    | BREAK SC          										{if(!DS->checkInWhile()) errorUnexpectedBreak(yylineno);}
                    | CONTINUE SC       										{if(!DS->checkInWhile()) errorUnexpectedContinue(yylineno);}
;

WhileM:             /*epsilon*/                                                 {DS->enterWhile();}
;

Call:               ID LPAREN ExpList RPAREN    								{checkVariables($1,$3);$$=new Expression(DS->getFunctionType($1));delete (ExpressionList*)$3}//check if variables fit called function
                    | ID LPAREN RPAREN          								{checkVariables($1,nullptr);$$=new Expression(DS->getFunctionType($1));}//check if function doesn't have variables
;

ExpList:            Exp                         								{$$=new ExpressionList();$$->addExpression($1);}
                    | Exp COMMA ExpList         								{$3->addExpression($1);}
;

Type:               INT                         								{$$ = new Type(TYPE_INT);}
                    | BYTE                      								{$$ = new Type(TYPE_BYTE);}
                    | BOOL                      								{$$ = new Type(TYPE_BOOL);}
;

Exp:                LPAREN Exp RPAREN           								{$$=$2;} 
                    | Exp MULTIPLICATIVE Exp           						    {($1->type>$3->type)?($$=$1):($$=$3);} // (x = 3 if 4>5 else 2) //x=2//expression should get the bigger type
                    | Exp ADDITIVE Exp           								{($1->type>$3->type)?($$=$1):($$=$3);} // (x = 3 if 4>5 else 2) //x=2//expression should get the bigger type
                    | ID                        								{;} //Expression should get same type as ID
                    | Call                      								{$$=$1;}
                    | NUM                       								{$$=new Expression(TYPE_INT);}
                    | NUM B                     								{$$=new Expression(TYPE_BYTE);}//when does it happen?
                    | STRING                    								{$$=new Expression(TYPE_STRING);}
                    | TRUE                      								{$$=new Expression(TYPE_BOOL);}
                    | FALSE                     								{$$=new Expression(TYPE_BOOL);}
                    | NOT Exp                   								{$$=$2;}
                    | Exp AND Exp               								{$$=$1;delete (Expression*)$3;}
                    | Exp OR Exp                								{$$=$1;delete (Expression*)$3;}
                    | Exp RELATIONAL Exp             							{$$=$1;delete (Expression*)$3}
                    | LPAREN Type RPAREN Exp    								{DS->compareTypesCast($2->type,$4->type);$$=new Expression($2->type);delete (Type*)$2;delete (Expression*)$4;}//check if legal 
                    | Exp IF LPAREN Exp RPAREN ELSE Exp                         {$$=$1;checkLegalCast((Expression*)$1->type,(Expression*)$7->type);checkIfBool((Expression*)$4->type);delete (Expression*)$7;(Expression*)$4}

;

%%

void yyerror(const char*)											
{
    errorSyn(yylineno); exit(1);
}

int main() 										
{
    GlobalSymbs* DS = new GlobalSymbs(); // this is our DS that contain all the symbols in the code
    //add functions print and printi to DS
	return yyparse();
}